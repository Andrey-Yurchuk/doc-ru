<?xml version="1.0" encoding="utf-8"?>
<!-- EN-Revision: c5d92fd7127e059d448d43ba339f19956f83b05a Maintainer: shein Status: ready -->
<!-- Reviewed: no -->
  <chapter xml:id="security.filesystem" xmlns="http://docbook.org/ns/docbook">
   <title>Безопасность файловой системы</title>
   <simpara>
    <acronym>PHP</acronym> подчиняется правилам безопасности, которые встроены в бо́льшую часть
    серверных систем в отношении разрешений для файлов и каталогов.
    Следование правилам разрешает разработчика управлять тем, какие файлы
    в файловой системе доступны для чтения.
    При настройке файлов, доступ на чтение которых открыт для мира,
    соблюдают осторожность, чтобы гарантировать, что файлы безопасны для чтения пользователями,
    для которых открыт доступ к файловой системе.
   </simpara>
   <simpara>
    Поскольку <acronym>PHP</acronym> разработали для доступа к файловой системе на уровне пользователя,
    можно написать <acronym>PHP</acronym>-скрипт,
    который разрешит читать системные файлы наподобие /etc/passwd,
    изменять Ethernet-соединениями, отправлять большие задания на печать и т. д.
    У этого есть ряд последствий, и поэтому нужно убедиться,
    что не возникла ошибка в выборе файла, который разработчик читает и в который записывает данные.
   </simpara>
   <simpara>
    Рассмотрим следующий скрипт, в котором пользователь указывает,
    что хотел бы удалить файл из пользовательского домашнего каталога.
    Это предполагает, что управление файлами регулярно использует
    веб-интерфейс <acronym>PHP</acronym>
    поэтому пользователю веб-сервера Apache разрешается удалять файлы
    в домашних каталогах пользователя.
   </simpara>
   <para>
    <example>
     <title>Недостаточная проверка переменных приводит к…</title>
     <programlisting role="php">
<![CDATA[
<?php

// Удаление файла из домашней директории пользователя
$username = $_POST['user_submitted_name'];
$userfile = $_POST['user_submitted_filename'];
$homedir  = "/home/$username";

unlink("$homedir/$userfile");

echo "Скрипт удалил файл!";

?>
]]>
     </programlisting>
    </example>
    Поскольку имя пользователя и название файла приходят
    из пользовательской формы, не исключается риск подмены и удаления данных,
    которые принадлежат другому пользователю, даже если у пользователя не было разрешения
    на удаление данных. Тогда требуется аутентификация.
    Посмотрим, что произойдёт, если отправить значения
    «../etc/» и «passwd». Тогда код будет выглядеть вот так:
    <example>
     <title>…атаке на файловую систему</title>
     <programlisting role="php">
<![CDATA[
<?php

// Удаляем файл из произвольного места на жестком диске,
// к которому пользователю PHP-скрипта открыт доступ. Если PHP работает с правами суперпользователя:
$username = $_POST['user_submitted_name']; // В переменной передали значение "../etc"
$userfile = $_POST['user_submitted_filename']; // В переменной передали значение "passwd"
$homedir  = "/home/$username"; // "/home/../etc"

unlink("$homedir/$userfile"); // "/home/../etc/passwd"

echo "Скрипт удалил файл!";

?>
]]>
     </programlisting>
    </example>
    Атаки предотвращают двумя способами.
    <itemizedlist>
     <listitem>
      <simpara>
       Ограничивают права доступа на двоичный файл веб-пользователя <acronym>PHP</acronym>.
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       Проверяют каждую переменную, которую передают пользователи.
      </simpara>
     </listitem>
    </itemizedlist>
    Вот улучшенный вариант кода:
    <example>
     <title>Более безопасная проверка имени файла</title>
     <programlisting role="php">
<![CDATA[
<?php

// Удаляем файл из произвольного места на жестком диске,
// к которому пользователю PHP-скрипта открыт доступ.
$username = $_SERVER['REMOTE_USER']; // Проверяем, прошёл ли пользователь аутентификацию
$userfile = basename($_POST['user_submitted_filename']);
$homedir  = "/home/$username";

$filepath = "$homedir/$userfile";

if (file_exists($filepath) && unlink($filepath)) {
    $logstring = "Функция удалила файл $filepath\n";
} else {
    $logstring = "Не удалось удалить файл $filepath\n";
}

$fp = fopen("/home/logging/filedelete.log", "a");
fwrite($fp, $logstring);
fclose($fp);

echo htmlentities($logstring, ENT_QUOTES);

?>
]]>
     </programlisting>
    </example>
    Однако даже такая проверка не лишена недостатков. Если
    система аутентификации разрешает пользователям создавать произвольные логины,
    и взломщик выбрал логин «../etc/», система снова становится уязвимой.
    Поэтому предпочитают более строгую проверку:
    <example>
     <title>Более строгая проверка имени файла</title>
     <programlisting role="php">
<![CDATA[
<?php

$username     = $_SERVER['REMOTE_USER']; // Проверяем, прошёл ли пользователь аутентификацию
$userfile     = $_POST['user_submitted_filename'];
$homedir      = "/home/$username";

$filepath     = "$homedir/$userfile";

if (!ctype_alnum($username) || !preg_match('/^(?:[a-z0-9_-]|\.(?!\.))+$/iD', $userfile)) {
    die("Неправильное имя пользователя или файл");
}

// etc...

?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Набор файлов, за которыми придётся следить разработчику,
    определяет операционная система, и включает
    системные файлы устройств /dev/ или COM1, конфигурационные файлы
    /etc/ и файлы с расширением .ini, хорошо известные
    области хранения файлов /home/, «Документы» и так далее.
    Поэтому обычно проще создать политику безопасности, которая запрещает
    всё, кроме того, что явно разрешили.
   </para>
   <sect1 xml:id="security.filesystem.nullbytes">
    <title>Нулевые байты и безопасность</title>
    <simpara>
     Поскольку для работы с файловой системой <acronym>PHP</acronym>
     использует нижележащие C-функции, то в этом случае возможна
     крайне неожиданная обработка нулевого байта.
     Так как нулевой байт означает конец строки в C, то строки, содержащие
     такой байт, не будут трактоваться полностью, а только до той
     позиции, в которой находится этот байт.

     Следующий пример содержит уязвимый код, демонстрирующий эту проблему:
    </simpara>
    <example>
     <title>Скрипт, уязвимый к нулевому байту</title>
     <programlisting role="php">
<![CDATA[
<?php
$file = $_GET['file']; // "../../etc/passwd\0"
if (file_exists('/home/wwwrun/'.$file.'.php')) {
    // file_exists возвратит true, т.к. /home/wwwrun/../../etc/passwd существует
    include '/home/wwwrun/'.$file.'.php';
    // будет подключён файл /etc/passwd
}
?>
]]>
     </programlisting>
    </example>
    <para>
     Таким образом, любая испорченная строка, используемая в операциях
     с файловой системой должна быть соответствующим образом проверена.
     Вот улучшенная версия предыдущего примера:
    </para>
    <example>
     <title>Корректная проверка входных данных</title>
     <programlisting role="php">
<![CDATA[
<?php
$file = $_GET['file'];

// Белый список возможных значений
switch ($file) {
    case 'main':
    case 'foo':
    case 'bar':
        include '/home/wwwrun/include/'.$file.'.php';
        break;
    default:
        include '/home/wwwrun/include/main.php';
}
?>
]]>
     </programlisting>
    </example>
   </sect1>

  </chapter>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
