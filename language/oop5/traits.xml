<?xml version="1.0" encoding="utf-8"?>
<!-- EN-Revision: 7341710fa635b4a969bc855a1e4619cdfa6b63f1 Maintainer: mch Status: ready -->
<!-- Reviewed: no -->
<sect1 xml:id="language.oop5.traits" xmlns="http://docbook.org/ns/docbook">
 <title>Трейты</title>
 <para>
  PHP реализует способ переиспользования кода, называемый трейтами (Traits).
 </para>
 <para>
  Трейт — механизм переиспользования кода в языках
  с поддержкой одиночного наследования, к которым относится PHP. Задача трейта —
  уменьшить ограничения одиночного наследования, разрешая разработчику легко
  переиспользовать наборы методов в нескольких независимых классах,
  которые находятся в разных иерархиях классов. Семантику комбинации трейтов
  и классов определили так, чтобы снизить уровень сложности, и избежать
  типичных проблем, свойственных множественному наследованию и примесям (Mixins).
 </para>
 <para>
  Трейт похож на класс, но предназначается только для группировки функциональности
  тонко контролируемым и согласованным образом. Нельзя создать отдельный экземпляр трейта.
  Трейт дополняет традиционное наследование и разрешает выстраивать
  горизонтальную композицию поведения; другими словами, трейт играет роль приложения к членам класса,
  которое не требует наследования.
 </para>

 <example xml:id="language.oop5.traits.basicexample">
  <title>Пример трейта</title>
  <programlisting role="php">
<![CDATA[
<?php

trait ezcReflectionReturnInfo
{
    function getReturnType() { /*1*/ }
    function getReturnDescription() { /*2*/ }
}

class ezcReflectionMethod extends ReflectionMethod
{
    use ezcReflectionReturnInfo;
    /* ... */
}

class ezcReflectionFunction extends ReflectionFunction
{
    use ezcReflectionReturnInfo;
    /* ... */
}

?>
]]>
  </programlisting>
 </example>

 <sect2 xml:id="language.oop5.traits.precedence">
  <title>Приоритет</title>
  <para>
   Член, который класс унаследовал из базового класса, переопределяется членом, который внедрился трейтом.
   Порядок приоритета выстраивается так, что методы трейта переопределяются методами текущего класса,
   а методы, которые класс унаследовал из базового класса, переопределяются методами трейта.
  </para>
  <example xml:id="language.oop5.traits.precedence.examples.ex1">
   <title>Пример того, в каком порядке выстраивается приоритет</title>
   <para>
    Метод, который класс унаследовал из базового класса, переопределяется методом, который внедрился
    в класс MyHelloWorld из трейта SayWorld. Поведение методов трейта повторяет поведение методов
    класса MyHelloWorld. Порядок приоритета такой: методами текущего класса
    переопределяются методы трейта, которыми переопределяются методы
    базового класса.
   </para>
   <programlisting role="php">
<![CDATA[
<?php

class Base
{
    public function sayHello()
    {
        echo 'Hello ';
    }
}

trait SayWorld
{
    public function sayHello()
    {
        parent::sayHello();
        echo 'World!';
    }
}

class MyHelloWorld extends Base
{
    use SayWorld;
}

$o = new MyHelloWorld();
$o->sayHello();

?>
]]>
   </programlisting>
   &example.outputs;
   <screen>
<![CDATA[
Hello World!
]]>
   </screen>
  </example>
  <example xml:id="language.oop5.traits.precedence.examples.ex2">
   <title>Пример альтернативного порядка приоритета</title>
   <programlisting role="php">
<![CDATA[
<?php

trait HelloWorld
{
    public function sayHello()
    {
        echo 'Hello World!';
    }
}

class TheWorldIsNotEnough
{
    use HelloWorld;

    public function sayHello()
    {
        echo 'Hello Universe!';
    }
}

$o = new TheWorldIsNotEnough();
$o->sayHello();

?>
]]>
   </programlisting>
   &example.outputs;
   <screen>
<![CDATA[
Hello Universe!
]]>
   </screen>
  </example>
 </sect2>

 <sect2 xml:id="language.oop5.traits.multiple">
  <title>Несколько трейтов</title>
  <para>
   Названия трейтов перечисляют через запятую в инструкции <literal>use</literal>,
   чтобы добавить в класс несколько трейтов.
  </para>
  <example xml:id="language.oop5.traits.multiple.ex1">
   <title>Пример внедрения нескольких трейтов</title>
   <programlisting role="php">
<![CDATA[
<?php

trait Hello
{
    public function sayHello()
    {
        echo 'Hello ';
    }
}

trait World
{
    public function sayWorld()
    {
        echo 'World';
    }
}

class MyHelloWorld
{
    use Hello, World;

    public function sayExclamationMark()
    {
        echo '!';
    }
}

$o = new MyHelloWorld();
$o->sayHello();
$o->sayWorld();
$o->sayExclamationMark();

?>
]]>
   </programlisting>
   &example.outputs;
   <screen>
<![CDATA[
Hello World!
]]>
   </screen>
  </example>
 </sect2>

 <sect2 xml:id="language.oop5.traits.conflict">
  <title>Разрешение конфликтов</title>
  <para>
   При добавлении двумя трейтами метода с одним и тем же названием возникает фатальная
   ошибка, если конфликт явно не разрешили.
  </para>
  <para>
   Оператор <literal>insteadof</literal> разрешает конфликты имён и указывает,
   метод какого трейта исключить из класса, когда название метода одного трейта совпадает
   с названием метода другого трейта, который включили в этот же класс.
  </para>
  <para>
   Для добавления псевдонима методу трейта указывают оператор <literal>as</literal>,
   поскольку предыдущий оператор только исключает методы.
   Обратите внимание, оператор <literal>as</literal>
   не переименовывает метод и не влияет ни на какие другие методы.
  </para>
  <example xml:id="language.oop5.traits.conflict.ex1">
   <title>Пример разрешения конфликтов</title>
   <para>
    В этом примере в класс Talker включили трейты A и B.
    Поскольку в трейтах A и B содержатся методы, которые вступают в конфликт,
    класс использует вариант метода smallTalk из трейта B, а вариант метода bigTalk из трейта A.
   </para>
   <para>
    Оператор <literal>as</literal> в классе Aliased_Talker
    разрешает вызывать метод bigTalk трейта B
    по псевдониму <literal>talk</literal>.
   </para>
   <programlisting role="php">
<![CDATA[
<?php

trait A
{
    public function smallTalk()
    {
        echo 'a';
    }

    public function bigTalk()
    {
        echo 'A';
    }
}

trait B
{
    public function smallTalk()
    {
        echo 'b';
    }

    public function bigTalk()
    {
        echo 'B';
    }
}

class Talker
{
    use A, B {
        B::smallTalk insteadof A;
        A::bigTalk insteadof B;
    }
}

class Aliased_Talker
{
    use A, B {
        B::smallTalk insteadof A;
        A::bigTalk insteadof B;
        B::bigTalk as talk;
    }
}

?>
]]>
   </programlisting>
  </example>
 </sect2>

 <sect2 xml:id="language.oop5.traits.visibility">
  <title>Изменение видимости метода</title>
  <para>
   Синтаксис с оператором <literal>as</literal> умеет также настраивать
   видимость метода в классе.
  </para>
  <example xml:id="language.oop5.traits.visibility.ex1">
   <title>Пример изменения видимости метода</title>
   <programlisting role="php">
<![CDATA[
<?php

trait HelloWorld
{
    public function sayHello()
    {
        echo 'Привет, мир!';
    }
}

// Изменим видимость метода sayHello
class MyClass1
{
    use HelloWorld {
        sayHello as protected;
    }
}

// Создадим псевдоним метода и изменим видимость этого метода.
// Видимость метода sayHello не изменилась
class MyClass2
{
    use HelloWorld {
        sayHello as private myPrivateHello;
    }
}

?>
]]>
   </programlisting>
  </example>
 </sect2>

 <sect2 xml:id="language.oop5.traits.composition">
  <title>Трейты, которые состоят из трейтов</title>
  <para>
   Аналогично внедрению в классы трейты разрешается внедрять в другие трейты.
   Трейт будет состоять из отдельных или всех членов других трейтов
   при внедрении одного или нескольких трейтов в определении трейта.
  </para>
  <example xml:id="language.oop5.traits.composition.ex1">
   <title>Пример трейтов, которые составили из трейтов</title>
   <programlisting role="php">
<![CDATA[
<?php

trait Hello
{
    public function sayHello()
    {
        echo 'Hello ';
    }
}

trait World
{
    public function sayWorld()
    {
        echo 'World!';
    }
}

trait HelloWorld
{
    use Hello, World;
}

class MyHelloWorld
{
    use HelloWorld;
}

$o = new MyHelloWorld();
$o->sayHello();
$o->sayWorld();

?>
]]>
   </programlisting>
   &example.outputs;
   <screen>
<![CDATA[
Hello World!
]]>
   </screen>
  </example>
 </sect2>

 <sect2 xml:id="language.oop5.traits.abstract">
  <title>Абстрактные члены трейтов</title>
  <para>
   Трейты поддерживают абстрактные методы, чтобы установить требования
   к классу, в который внедрится трейт.
   Поддерживаются общедоступные, защищённые и закрытые методы.
   До PHP 8.0.0 поддерживались только общедоступные и защищённые абстрактные методы.
  </para>
  <caution>
   <simpara>
    Начиная с PHP 8.0.0 выдаётся фатальная ошибка, если сигнатура конкретного метода
    не следует <link linkend="language.oop.lsp">правилам совместимости сигнатур</link>.
    Раньше при несовпадении сигнатуры метода ошибка не выдавалась.
   </simpara>
  </caution>
  <example xml:id="language.oop5.traits.abstract.ex1">
   <title>Пример установки требований к классу через абстрактный метод трейта</title>
   <programlisting role="php">
<![CDATA[
<?php

trait Hello
{
    public function sayHelloWorld()
    {
        echo 'Hello' . $this->getWorld();
    }

    abstract public function getWorld();
}

class MyHelloWorld
{
    private $world;

    use Hello;

    public function getWorld()
    {
        return $this->world;
    }

    public function setWorld($val)
    {
        $this->world = $val;
    }
}

?>
]]>
   </programlisting>
  </example>
 </sect2>

 <sect2 xml:id="language.oop5.traits.static">
  <title>Статические члены трейта</title>
  <para>
   В трейтах разрешается определять статические переменные, статические методы и статические свойства.
  </para>
  <note>
   <para>
    Начиная с PHP 8.1.0 прямой вызов статического метода
    или прямой доступ к статическому свойству в трейте устарели.
    Доступ к статическим методам и свойствам получают только в классе, в который внедрили трейт.
   </para>
  </note>
  <example xml:id="language.oop5.traits.static.ex1">
   <title>Статические переменные</title>
   <programlisting role="php">
<![CDATA[
<?php

trait Counter
{
    public function inc()
    {
        static $c = 0;
        $c = $c + 1;
        echo "$c\n";
    }
}

class C1
{
    use Counter;
}

class C2
{
    use Counter;
}

$o = new C1();
$o->inc(); // echo 1
$p = new C2();
$p->inc(); // echo 1

?>
]]>
   </programlisting>
  </example>
  <example xml:id="language.oop5.traits.static.ex2">
   <title>Статические методы</title>
   <programlisting role="php">
<![CDATA[
<?php

trait StaticExample
{
    public static function doSomething()
    {
        echo 'Делаем что-нибудь';
    }
}

class Example
{
    use StaticExample;
}

Example::doSomething();

?>
]]>
   </programlisting>
  </example>
  <example xml:id="language.oop5.traits.static.ex3">
   <title>Статические свойства</title>
   <programlisting role="php">
<![CDATA[
<?php

trait StaticExample
{
    public static $static = 'foo';
}

class Example
{
    use StaticExample;
}

echo Example::$static;

?>
]]>
  </programlisting>
 </example>
 </sect2>

 <sect2 xml:id="language.oop5.traits.properties">
  <title>Свойства</title>
  <para>
   В трейтах доступно определение свойств.
  </para>
  <example xml:id="language.oop5.traits.properties.example">
   <title>Пример определения свойств в трейте</title>
   <programlisting role="php">
<![CDATA[
<?php

trait PropertiesTrait
{
    public $x = 1;
}

class PropertiesExample
{
    use PropertiesTrait;
}

$example = new PropertiesExample();
$example->x;

?>
]]>
   </programlisting>
  </example>
  <para>
   В классе нельзя определять свойство с названием как у свойства трейта,
   если свойство класса несовместимо со свойством трейта по области видимости и типу,
   модификатору readonly и начальному значению, иначе PHP выдаёт фатальную ошибку.
  </para>
  <example xml:id="language.oop5.traits.properties.conflicts">
   <title>Разрешение конфликтов</title>
   <programlisting role="php">
<![CDATA[
<?php

trait PropertiesTrait
{
    public $same = true;
    public $different1 = false;
    public bool $different2;
    public bool $different3;
}

class PropertiesExample
{
    use PropertiesTrait;

    public $same = true;
    public $different1 = true; // Фатальная ошибка
    public string $different2; // Фатальная ошибка
    readonly protected bool $different3; // Фатальная ошибка
}

?>
]]>
   </programlisting>
  </example>
 </sect2>

 <sect2 xml:id="language.oop5.traits.constants">
  <title>&Constants;</title>
  <para>
   Начиная с версии PHP 8.2.0 в трейтах разрешили также определять константы.
  </para>
  <example xml:id="language.oop5.traits.constants.example">
   <title>Определение констант</title>
   <programlisting role="php">
<![CDATA[
<?php

trait ConstantsTrait
{
    public const FLAG_MUTABLE = 1;
    final public const FLAG_IMMUTABLE = 5;
}

class ConstantsExample
{
    use ConstantsTrait;
}

$example = new ConstantsExample;
echo $example::FLAG_MUTABLE; // 1

?>
]]>
   </programlisting>
  </example>
  <para>
   В классе нельзя определять константу с названием как у константы трейта,
   если константа класса несовместима с константой трейта по области видимости,
   начальному значению и модификатору final, иначе PHP выдаёт фатальную ошибку.
  </para>
  <example xml:id="language.oop5.traits.constants.conflicts">
   <title>Разрешение конфликтов</title>
   <programlisting role="php">
<![CDATA[
<?php

trait ConstantsTrait
{
    public const FLAG_MUTABLE = 1;
    final public const FLAG_IMMUTABLE = 5;
}

class ConstantsExample
{
    use ConstantsTrait;

    public const FLAG_IMMUTABLE = 5; // Фатальная ошибка
}

?>
]]>
   </programlisting>
  </example>
 </sect2>

</sect1>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
