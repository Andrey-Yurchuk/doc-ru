<?xml version="1.0" encoding="utf-8"?>
<!-- EN-Revision: c7e29d3ab5328b52f83edb88bde973e211a37659 Maintainer: sergey Status: ready -->
<!-- Reviewed: no -->
<chapter xml:id="philosophy.parallel" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
 <title>Философия</title>
 <para>
  Раздел содержит основные принципы, важные для написания параллельного кода и некоторые подробности о внутренней реализации parallel.
 </para>
 <simplesect role="sharing">
   <title>Не общайтесь, разделяя память; вместо этого поделитесь памятью, с помощью общения.</title>
   <para>
    Эта философия, которой придерживается parallel, берёт своё начало из Go, одной из самых популярных из используемых платформ для написания параллельного кода в настоящее время.
    Программисты на Go должны упорно трудиться, чтобы соответствовать этому идеалу: PHP и параллельный интерфейс делают всю тяжёлую работу за программиста,
    причём по умолчанию.
   </para>
   <para>
    В традиционных моделях потоковой передачи, встречающихся в других языках, потоки обычно обмениваются данными друг с другом только благодаря тому факту, что они работают в одном и том же адресном пространстве.
    Программист должен использовать взаимное исключение, переменные условия и другие низкоуровневые примитивы потоковой передачи или синхронизации, чтобы обеспечить надлежащую передачу состояния и согласованность.
   </para>
   <para>
    Когда обычная модель инвертирована, это означает, что потоки совместно используют память только в результате обмена данными (например, переменная передаётся по каналу).
   </para>
   <para>
    Когда parallel передаёт переменную из одного потока в другой любым способом - аргументами задачи, возвратом через Future и каналами - она передаётся по значению.
    Во всех случаях, кроме небуферизованных каналов, переменная также буферизуется, поэтому она не может измениться (или быть уничтожена) до того, как она будет использована в любом потоке,
    в который передаётся переменная. Небуферизованное чтение по каналу - единственный случай, когда поток непосредственно читает память,
    выделенную другим потоком, это можно сделать безопасно, потому что поток, владеющий памятью, ожидает завершения чтения, прежде чем он сможет продолжить управлять им, и поток, которому не принадлежит память, читает по значению.
    Когда оба потока продолжают работу, они больше не разделяют память.
   </para>
   <para>
    Это значительно упрощает написание параллельного кода и рассуждения о нём по сравнению с традиционной моделью многопоточности.
    Это означает, что программисту не нужно учитывать, что потоки могут одновременно управлять данными, потому что это невозможно.
   </para>
   <para>
    Это также делает PHP идеальной платформой для реализации API параллельного кода на основе CSP (передача сообщений по каналам),
    поскольку сам PHP ничего не разделяет - потоки PHP по умолчанию работают в собственном виртуальном адресном пространстве и поэтому могут совместно использовать память только путём обмена данными.
   </para>
 </simplesect>
 <simplesect role="owning">
  <title>У данных должен быть окончательный единственный владелец</title>
  <para>
   Приближаясь к модели CSP в первый раз, программист, разбирающийся в традиционной модели потоковой передачи,
   может обнаружить, что ищет параллельные структуры данных, потому что это то,
   что они тоже используют: они передают общие объекты для управления.
  </para>
  <para>
   Когда дело доходит до модели CSP, нет необходимости в том, чтобы структуры данных совместно использовались многими задачами и действительно,
   это проще, если это не так. Данные должны принадлежать одной задаче, изменения (или операции) в этой структуре данных должны передаваться по каналам
   и выполняться владельцем данных, успешное выполнение, ошибка или результат (состояние) изменения (или операции) передаётся обратно.
  </para>
  <para>
   Опять же, природа PHP ничего не разделяет и природа параллельного копирования по значению помогают программисту достичь этой цели, никакие данные не будут переданы случайно, только в результате обмена данными.
  </para>
 </simplesect>
</chapter>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
